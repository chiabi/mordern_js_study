# 모던 자바스크립트 라이브러리 프레임워크 (DAY03)

Vue, wepack

왜 앵귤러 리액트 뷰등의 프레임워크가 등장했는가.
progressive : 부분, 부분 만들어 조립해 큰 것을 만드는.

웹 애플리케이션

과거에는 데이터베이스에서 데이터를 불러와 화면단에 보여주는 것(HTML생성)을 백엔드에서 처리햇는데
자바스크립트의 성장으로 클라이언트에서 백엔드에서 가져온 데이터를 자바스크립트를 통해 처리(HTML, CSS, JAVASCRIPT)한다.

AJAX -> [SPA] -> HTML
SPA 단점: 
1. 대규모 애플리케이션에서는 장점이 될 수 없음, 서버사이드 렌더링 방식으로 해야함
-> 뷰는 이에 대한 솔루션도 제공하고 있다.
2. 검색 노출이 중요할 경우에는 좋은 선택이 아니다.(광고, 마케팅이 중요한 경우) - 동적인 부분을 검색엔진이 기다려주지 않음 

vue는 PWA, NATIVE APP이든 가능하다.

클라이언트에 정보를 저장할 공간이 필요하다 : DOM에 스토리지 기술이 추가되었다. (구형 브라우저는 스토리지 기능이 없어 쿠키, 세션등의 대체 수단이 필요하다.)

자바스크립트의 역량 성장으로 클라이언트에서의 역할이 커졌다.

복잡한 클라이언트의 사이드 스크립트 스택을 도와줄 프레임워크의 필요성 대두

리액트나 뷰는 라이브러리지만 확장 가능한 기능을 가지고 있으므로 프레임워크라 할 수 있다.

뷰 : DOM 이벤트 핸들링, REST비동기 통신, SPA 라우팅, 상태관리(데이터 관리) -> 제이쿼리는 DOM이벤트 핸들링만 할 수 있다.

DATA, CODE -> vuex -> DATA -> vue -> HTML
vuex: 리액트로 치면 리덕스, 데이터를 관리해줌

초경량 프레임워크(16kb - 제이쿼리는 8*.kb)

컴포넌트 지향 UI(컴포넌트 중심)
: (HTML도 커스텀 엘리먼트를 사용할 수 있지만 구형 브라우저에서 지원하지 않는다.(표준) -> 유튜브는 하고 있다.)
자바스크립트의 스코프 개념이 DOM에 들어오게 되었다.  (기존에는 DIV로...)

리 액티비티 시스템: 반응형(RESPONSIVE아님 , REPONSE의 개념) 웹 - 데이터 변경 시 뷰의 아키텍쳐로 인해 바로 변경

데이터바인딩(앵귤러 스타일) 시스템(모델 데이터를 템플리셍 바인딩하는 시스템)

단점 : IE8이하는 지원하지 않음 -> ECMAScript5를 사용하기 때문

UI를 구현해주는 뷰 레이어 코어(라이브러리) + 선택적으로 라이브러리 사용 가능(서드파티 라이브러리등) -> 점진적 프레임워크

## 뷰가 제공하는 기능
1. 선언적 렌더링방식(앵귤러)
1. 컴포넌트 시스템(리액트)
1. 클라이언트 기반 라우팅
1. 대형 프로텍트 상태 관리 매니저
1. 빌드시스템  
ROLLUP은 멀티가 안되니까 라이브러리 만들때 쓰면 졸을 것 같고, NPM은 네이티브이고 WEBPACK을 사용하는 게 좋다. 
1. 클라이언트 서버간, 지속적인 데이터 교류

제이쿼리는 돔 조작의 수준이고 데이터 관리는 아님
DOM을 잘 모르고 쓰는 사람이 많아 느리다. -> 캐시해서 쓴다거나...

리플로우, 리페인팅

### 선언 & 반응하는 렌더링

컴포넌트 커뮤니케이션 전달, 커스텀 이벤트 방출 


### https://unpkg.com/#/

npm에 있는 패키지를 제공해준다.

https://unpkg.com/jquery@3.2.1/

https://vuejs.org/

뷰를 가지고 개발할 때는 development version을 사용해야한다. 디버그 해주는 기능이 포함되어 있음

## 앵귤러(V.1), 리액트, 뷰 비교

앵귤러는 액츄얼 DOM을 사용하기 때문에(실제 코드에 비표준 속성을 추가해버린다;;) 비표준,  
리액트와 뷰는 버츄얼 DOM 시스템을 사용해 표준을 준수한다.(변경사항 부분만 HTML에 붙여주는 알고리즘을 사용한단)  
앵귤러 사용 사이트 참고(JANDI APP)

리액트와는 사용자와의 편의성에 차이가 있다.
리액트는 바벨, ES6코드를 써야한다(class를 사용한다.) -> ES6를 학습해야한다., vue는 ES5를 써도 된다.

뷰는 Virtual Dom이 감춰져있다. 리액트처럼 버츄얼돔, 렌더를 따로 구분해서 작성할 필요가 없다.
선언적 바인딩을 통해 탬플릿에 간단하게 마운트한다.

리액트는 양방향 바인딩을 지원하지 않아 사용자가 만들어야한다.  
초기 데이터값, 수정하는부분, 이벤트 바인딩부분을 나눠 작성해야한다. -> 뷰와 리액트는 코드량에서도 차이가 난다.

뷰의 양방향 데이터 바인딩을 네이티브로 구현한다고 하면 지속적인 변경 감시 코드가 필요하다(작성해야한다.)

### 액츄얼돔 Actual DOM

실제 돔을 조작하는 것은 느리고 비용이 많이 든다.

SSR(Server Side Rendering) -> 속도가 느리다. 새로운 돔을 생성한 후, 응답해주는 프로세스가 사용 되었다.
불필요하고 시간이 많이 드는 케이스

초창기 프레임워크: 백본, dojo ext.js
상태변경을 이벤트를 통해 직접바꾸는 일을 해야함 

ember 등 두번째 프레임워크: 
자동으로 업데이트 바인딩(작은 거 만들 때 굳이 비대하게 작업해야하는가??)

앵귤러 버전 1:
실제 돔을 모델과 다 연결해 관찰자(watcher)를 통해 지속적인 변경  
변화가 없음에도 계속 변화를 물어봐 느렸다.

리액트 : 
버츄얼 돔,가상돔을 만들어 데이터 바인딩, 버츄얼 돔에서 변경된 부분을 확인(diff)해 변경된 부분만 실제 DOM에 반영한다.

제이쿼리는 실제 돔을 자꾸 건드려서 좋을 것이 없다.

버츄얼돔 내부 로직(4개)
H.js- (하이퍼 스크립트 h)
diff.js


### 뷰 인스턴스

라이프사이클 훅(생명주기 함수)

뷰 인스턴스에서 정의한 메서드의 this는 `this.data.count`처럼 사용해야할 것 같지만 내부적으로 프록시를 이용해 우회하여 `this.count`로 사용할 수 있게 한다.  
화살표 함수를 사용할 경우 `this`가 의도대로 사용되지 않을 수 있으니 메서드 정의시에는 사용하지 않는다.

data 객체에 있는 모든 속성을 프록시 처리 한다.  
애플리케이션에서 반응성으로 관리하기 위해서는 초기에 data에 속성이 있어야한다.
나중에 동적으로 추가한 속성은 옵저버가 관찰하지 않는다. 부트스트래핑 과정에서 초기화되지 않았기 때문에



```javascript
class RmoteController {
    // countructor 함수
    constructor() {
        // #붙이면 private이다라는 것이 추가될 예정 지금은 쓸 수없;;;
        // this.#privateMember = '보안처리된 감춰진 속성';
    }
    // countructor 멤버
    static register() {}
    // prototype 멤버
    init() {}
}
```

stage-3 TC39의 연구단계를 의미

--hot 자동으로 리프레쉬

computed는 getter 매개변수 없음 성능 관점에서는 method보다 낫지만 매개변수를 받지 못함 

뷰는 부모 컴포넌트의 것을 받을때 형 지정, 필수로 받아야하는 지 등을 자식컴포넌트에서 props를 통해 정할 수 있다.
